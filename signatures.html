<html>
<head>
<meta charset="UTF-8">
<title>Steem Tx Sign</title>
</head>
<body>

<textarea id="tx" rows="15" cols="60">
</textarea>

<br><br>
<button onclick="signTx()">署名する</button>

<br><br>
<textarea id="result" rows="15" cols="60"></textarea>
<br><br>
<textarea id="result2" rows="15" cols="60"></textarea>

<script>
// 最新ブロック情報取得
async function getDynamicGlobalProperties() {
  const res = await fetch("https://api.steememory.com", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "get_dynamic_global_properties",
      params: [],
      id: 1
    })
  });

  const data = await res.json();
  return data.result;
}

function calculateRefBlockPrefix(blockId) {
  // block_id の先頭8文字（4バイト）を取り出す
  const prefixHex = blockId.substring(0, 8);

  // Little Endian に変換
  const leHex =
    prefixHex.substring(6, 8) +
    prefixHex.substring(4, 6) +
    prefixHex.substring(2, 4) +
    prefixHex.substring(0, 2);

  return parseInt(leHex, 16);
}

async function main() {
  const props = await getDynamicGlobalProperties();

  const head_block_number = props.head_block_number;
  const head_block_id = props.head_block_id;

  // Bash と同じ → 16bit にする
  const ref_block_num = head_block_number & 0xFFFF;

  // Bash と同じ Little Endian 計算
  const ref_block_prefix = calculateRefBlockPrefix(head_block_id);

  console.log("ref_block_num =", ref_block_num);
  console.log("ref_block_prefix =", ref_block_prefix);

  // JSON 作成（bash の keychain_transfer.json と同じ）
  const tx = {
    ref_block_num: ref_block_num,
    ref_block_prefix: ref_block_prefix,
    expiration: new Date(Date.now() + 2 * 60 * 1000)
      .toISOString()
      .split(".")[0], // bash の +%Y-%m-%dT%H:%M:%S と同じ
    operations: [
      [
        "transfer",
        {
          from: "usay",
          to: "usay",
          amount: "0.001 STEEM",
          memo: "test"
        }
      ]
    ],
    extensions: []
  };

  // ファイルに保存
  //const fs = await import("fs");
  //fs.writeFileSync("keychain_transfer.json", JSON.stringify(tx, null, 2));

    console.log(  JSON.stringify(tx, null, 2));
    console.log("keychain_transfer.json を作成しました");
  
}

main();

</script>

<script>
// ============= Steem バイナリエンコード =============
function encodeVarInt(value) {
    const bytes = [];
    while (value >= 0x80) {
        bytes.push((value & 0x7f) | 0x80);
        value >>= 7;
    }
    bytes.push(value);
    return bytes;
}

function encodeString(str) {
    const enc = new TextEncoder().encode(str);
    return [...encodeVarInt(enc.length), ...enc];
}

function encodeAsset(str) {
    const [amountRaw, symbol] = str.split(" ");
    const amount = parseFloat(amountRaw);
    const precision = (amountRaw.split(".")[1] || "").length;
    const number = Math.round(amount * Math.pow(10, precision));

    const buf = [];
    buf.push(...new Uint8Array(new Uint32Array([number]).buffer)); // amount
    buf.push(precision); // precision

    const symBytes = new TextEncoder().encode(symbol);
    const symbolBuf = new Uint8Array(7);
    symbolBuf.set(symBytes);

    buf.push(...symbolBuf);
    return buf;
}

function encodeOperation(op) {
    const [type, data] = op;

    if (type !== "transfer") throw "未対応の operation";

    let out = [];
    out.push(2); // transfer = op_type=2

    out.push(...encodeString(data.from));
    out.push(...encodeString(data.to));
    out.push(...encodeAsset(data.amount));
    out.push(...encodeString(data.memo));

    return out;
}

function serializeTx(tx) {
    let out = [];

    out.push(...new Uint16Array([tx.ref_block_num])); // 2 bytes
    out.push(...new Uint32Array([tx.ref_block_prefix])); // 4 bytes

    out.push(...encodeString(tx.expiration)); // 実際は timestamp 4byte

    out.push(1); // operations count
    out.push(...encodeOperation(tx.operations[0]));

    out.push(0); // extensions count

    return new Uint8Array(out);
}

// ============= SHA256 =============
async function sha256(bin) {
    const hash = await crypto.subtle.digest("SHA-256", bin);
    return Array.from(new Uint8Array(hash))
        .map(x => x.toString(16).padStart(2, "0"))
        .join("");
}

// ============= 署名処理 =============
async function signTx() {
    const resultEl = document.getElementById("result");

    if (!window.steem_keychain) {
        resultEl.value = "Keychainがありません";
        return;
    }

    let tx;
    try {
        tx = JSON.parse(document.getElementById("tx").value);
        document.getElementById("tx").value = JSON.stringify(tx);

    } catch (e) {
        resultEl.value = "JSONエラー: " + e.message;
        return;
    }

    // ① Tx → Steemバイナリ
    const bin = serializeTx(tx);

    // ② バイナリ SHA256
    const hashHex = await sha256(bin);

    // ③ Keychain 署名
    steem_keychain.requestSignBuffer("usay", hashHex, "active", (res) => {
        resultEl.value = JSON.stringify(res, null, 2);

        //const resultEl2 = document.getElementById("result2");
        //resultEl.value  = `curl -d '{"id":"0","jsonrpc":"2.0","method":"call","params":["condenser_api","broadcast_transaction_synchronous",[` + JSON.stringify(tx, null, 2) + 
    });



}
</script>

</body>
</html>
