<html>
<head>
<meta charset="UTF-8">
<title>Steem Tx Sign</title>
</head>
<body>

<textarea id="tx" rows="15" cols="60">
{
  "ref_block_num": 23013,
  "ref_block_prefix": 3847817478,
  "expiration": "2025-11-29T11:30:47",
  "operations": [
    ["transfer", {
      "from": "usay",
      "to": "usay",
      "amount": "0.001 STEEM",
      "memo": "test"
    }]
  ],
  "extensions": []
}
</textarea>

<br><br>
<button onclick="signTx()">署名する</button>

<br><br>
<textarea id="result" rows="15" cols="60"></textarea>

<script>
// ============= Steem バイナリエンコード =============
function encodeVarInt(value) {
    const bytes = [];
    while (value >= 0x80) {
        bytes.push((value & 0x7f) | 0x80);
        value >>= 7;
    }
    bytes.push(value);
    return bytes;
}

function encodeString(str) {
    const enc = new TextEncoder().encode(str);
    return [...encodeVarInt(enc.length), ...enc];
}

function encodeAsset(str) {
    const [amountRaw, symbol] = str.split(" ");
    const amount = parseFloat(amountRaw);
    const precision = (amountRaw.split(".")[1] || "").length;
    const number = Math.round(amount * Math.pow(10, precision));

    const buf = [];
    buf.push(...new Uint8Array(new Uint32Array([number]).buffer)); // amount
    buf.push(precision); // precision

    const symBytes = new TextEncoder().encode(symbol);
    const symbolBuf = new Uint8Array(7);
    symbolBuf.set(symBytes);

    buf.push(...symbolBuf);
    return buf;
}

function encodeOperation(op) {
    const [type, data] = op;

    if (type !== "transfer") throw "未対応の operation";

    let out = [];
    out.push(2); // transfer = op_type=2

    out.push(...encodeString(data.from));
    out.push(...encodeString(data.to));
    out.push(...encodeAsset(data.amount));
    out.push(...encodeString(data.memo));

    return out;
}

function serializeTx(tx) {
    let out = [];

    out.push(...new Uint16Array([tx.ref_block_num])); // 2 bytes
    out.push(...new Uint32Array([tx.ref_block_prefix])); // 4 bytes

    out.push(...encodeString(tx.expiration)); // 実際は timestamp 4byte

    out.push(1); // operations count
    out.push(...encodeOperation(tx.operations[0]));

    out.push(0); // extensions count

    return new Uint8Array(out);
}

// ============= SHA256 =============
async function sha256(bin) {
    const hash = await crypto.subtle.digest("SHA-256", bin);
    return Array.from(new Uint8Array(hash))
        .map(x => x.toString(16).padStart(2, "0"))
        .join("");
}

// ============= 署名処理 =============
async function signTx() {
    const resultEl = document.getElementById("result");

    if (!window.steem_keychain) {
        resultEl.value = "Keychainがありません";
        return;
    }

    let tx;
    try {
        tx = JSON.parse(document.getElementById("tx").value);
    } catch (e) {
        resultEl.value = "JSONエラー: " + e.message;
        return;
    }

    // ① Tx → Steemバイナリ
    const bin = serializeTx(tx);

    // ② バイナリ SHA256
    const hashHex = await sha256(bin);

    // ③ Keychain 署名
    steem_keychain.requestSignBuffer("usay", hashHex, "active", (res) => {
        resultEl.value = JSON.stringify(res, null, 2);
    });
}
</script>

</body>
</html>
